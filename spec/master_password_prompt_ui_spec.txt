# frozen_string_literal: true

require 'rspec'
require_relative '../lib/common/gui/master_password_prompt_ui'

RSpec.describe Lich::Common::GUI::MasterPasswordPromptUI do
  describe '.show_dialog' do
    let(:instance) { described_class.new }

    context 'when user provides valid matching passwords and clicks OK' do
      it 'returns the password' do
        allow(Gtk::Dialog).to receive(:new).and_wrap_original do |_method, *_args|
          dialog_mock = instance_double(Gtk::Dialog)
          allow(dialog_mock).to receive(:set_default_size)
          allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
          allow(dialog_mock).to receive(:show_all)
          allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::OK)
          allow(dialog_mock).to receive(:destroy)
          dialog_mock
        end

        allow_any_instance_of(described_class).to receive(:password_entry_text).and_return('StrongPass123!')
        allow_any_instance_of(described_class).to receive(:confirm_entry_text).and_return('StrongPass123!')

        result = instance.show_dialog

        expect(result).to eq('StrongPass123!')
      end
    end

    context 'when user cancels dialog' do
      it 'returns nil' do
        allow(Gtk::Dialog).to receive(:new).and_wrap_original do |_method, *_args|
          dialog_mock = instance_double(Gtk::Dialog)
          allow(dialog_mock).to receive(:set_default_size)
          allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
          allow(dialog_mock).to receive(:show_all)
          allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::CANCEL)
          allow(dialog_mock).to receive(:destroy)
          dialog_mock
        end

        result = instance.show_dialog

        expect(result).to be_nil
      end
    end

    context 'when passwords do not match' do
      it 'shows error and returns nil' do
        allow(Gtk::Dialog).to receive(:new).and_wrap_original do |_method, *_args|
          dialog_mock = instance_double(Gtk::Dialog)
          allow(dialog_mock).to receive(:set_default_size)
          allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
          allow(dialog_mock).to receive(:show_all)
          allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::OK)
          allow(dialog_mock).to receive(:destroy)
          dialog_mock
        end

        expect(instance).to receive(:show_error_dialog)
          .with("Passwords do not match")

        allow_any_instance_of(described_class).to receive(:password_entry_text).and_return('StrongPass123!')
        allow_any_instance_of(described_class).to receive(:confirm_entry_text).and_return('DifferentPass456')

        result = instance.show_dialog

        expect(result).to be_nil
      end
    end

    context 'when password is empty' do
      it 'shows error and returns nil' do
        allow(Gtk::Dialog).to receive(:new).and_wrap_original do |_method, *_args|
          dialog_mock = instance_double(Gtk::Dialog)
          allow(dialog_mock).to receive(:set_default_size)
          allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
          allow(dialog_mock).to receive(:show_all)
          allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::OK)
          allow(dialog_mock).to receive(:destroy)
          dialog_mock
        end

        expect(instance).to receive(:show_error_dialog)
          .with("Password cannot be empty")

        allow_any_instance_of(described_class).to receive(:password_entry_text).and_return('')
        allow_any_instance_of(described_class).to receive(:confirm_entry_text).and_return('')

        result = instance.show_dialog

        expect(result).to be_nil
      end
    end
  end

  describe '#calculate_password_strength' do
    let(:instance) { described_class.new }

    context 'with empty password' do
      it 'returns 0' do
        result = instance.send(:calculate_password_strength, '')

        expect(result).to eq(0)
      end
    end

    context 'with password of different lengths' do
      it 'awards 4 points per character up to 40 max' do
        # 5 chars = 20 points
        result_5 = instance.send(:calculate_password_strength, 'abcde')
        expect(result_5).to be >= 20

        # 10 chars = 40 points
        result_10 = instance.send(:calculate_password_strength, 'abcdefghij')
        expect(result_10).to be >= 40

        # 15 chars = would be 60 but capped at 40
        result_15 = instance.send(:calculate_password_strength, 'abcdefghijklmno')
        expect(result_15).to be >= 40
      end
    end

    context 'with uppercase letters' do
      it 'awards 10 points' do
        result_no_upper = instance.send(:calculate_password_strength, 'abcdefghij')
        result_with_upper = instance.send(:calculate_password_strength, 'Abcdefghij')

        expect(result_with_upper).to be > result_no_upper
      end
    end

    context 'with lowercase letters' do
      it 'awards 10 points' do
        result_no_lower = instance.send(:calculate_password_strength, 'ABCDEFGHIJ')
        result_with_lower = instance.send(:calculate_password_strength, 'ABCDEFGHIj')

        expect(result_with_lower).to be > result_no_lower
      end
    end

    context 'with numbers' do
      it 'awards 10 points' do
        result_no_numbers = instance.send(:calculate_password_strength, 'abcdefghij')
        result_with_numbers = instance.send(:calculate_password_strength, 'abcdefgh1j')

        expect(result_with_numbers).to be > result_no_numbers
      end
    end

    context 'with special characters' do
      it 'awards 10 points' do
        result_no_special = instance.send(:calculate_password_strength, 'abcdefghij')
        result_with_special = instance.send(:calculate_password_strength, 'abcdefgh!j')

        expect(result_with_special).to be > result_no_special
      end
    end

    context 'with all character types' do
      it 'awards variety bonus' do
        result_all_types = instance.send(:calculate_password_strength, 'Abcdefgh1!')

        # Should have: length, all 4 categories, variety bonus
        expect(result_all_types).to be > 80
      end
    end

    context 'score capping' do
      it 'caps score at 100' do
        very_long_strong = 'Abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()'
        result = instance.send(:calculate_password_strength, very_long_strong)

        expect(result).to eq(100)
      end
    end

    context 'with edge case characters' do
      it 'recognizes special characters correctly' do
        special_chars = 'abcdefgh!@#$%^&*-_=+[]{}' + "';:\"" + '<>?,./\\|`~'
        result = instance.send(:calculate_password_strength, special_chars)

        expect(result).to be > 0
      end
    end
  end

  describe '#get_strength_label' do
    let(:instance) { described_class.new }

    context 'with score 0-20' do
      it 'returns "Very Weak"' do
        result = instance.send(:get_strength_label, 10)

        expect(result).to eq('Very Weak')
      end
    end

    context 'with score 21-40' do
      it 'returns "Weak"' do
        result = instance.send(:get_strength_label, 35)

        expect(result).to eq('Weak')
      end
    end

    context 'with score 41-60' do
      it 'returns "Fair"' do
        result = instance.send(:get_strength_label, 50)

        expect(result).to eq('Fair')
      end
    end

    context 'with score 61-80' do
      it 'returns "Good"' do
        result = instance.send(:get_strength_label, 70)

        expect(result).to eq('Good')
      end
    end

    context 'with score 81-100' do
      it 'returns "Strong"' do
        result = instance.send(:get_strength_label, 90)

        expect(result).to eq('Strong')
      end
    end

    context 'with boundary scores' do
      it 'handles 0' do
        result = instance.send(:get_strength_label, 0)
        expect(result).to eq('Very Weak')
      end

      it 'handles 20' do
        result = instance.send(:get_strength_label, 20)
        expect(result).to eq('Very Weak')
      end

      it 'handles 21' do
        result = instance.send(:get_strength_label, 21)
        expect(result).to eq('Weak')
      end

      it 'handles 100' do
        result = instance.send(:get_strength_label, 100)
        expect(result).to eq('Strong')
      end
    end
  end

  describe '#update_category_icon' do
    let(:instance) { described_class.new }

    context 'when category is present' do
      it 'updates icon to checked with color' do
        icon_label = instance_double(Gtk::Label)
        color_code = '#44ff44'

        expect(icon_label).to receive(:markup=)
          .with("<span foreground='#{color_code}'>âœ“</span>")

        instance.send(:update_category_icon, icon_label, true, color_code)
      end
    end

    context 'when category is absent' do
      it 'updates icon to unchecked gray' do
        icon_label = instance_double(Gtk::Label)
        color_code = '#44ff44'

        expect(icon_label).to receive(:markup=)
          .with("<span foreground='gray'>âœ—</span>")

        instance.send(:update_category_icon, icon_label, false, color_code)
      end
    end

    context 'with various color codes' do
      let(:icon_label) { instance_double(Gtk::Label) }

      it 'updates with red' do
        expect(icon_label).to receive(:markup=)
          .with(/<span foreground='#ff4444'>âœ“<\/span>/)

        instance.send(:update_category_icon, icon_label, true, '#ff4444')
      end

      it 'updates with green' do
        expect(icon_label).to receive(:markup=)
          .with(/<span foreground='#44ff44'>âœ“<\/span>/)

        instance.send(:update_category_icon, icon_label, true, '#44ff44')
      end
    end
  end

  describe '#show_error_dialog' do
    let(:instance) { described_class.new }

    it 'creates error message dialog' do
      message = 'Test error message'

      expect(Gtk::MessageDialog).to receive(:new)
        .with(
          parent: nil,
          flags: Gtk::Dialog::MODAL,
          type: Gtk::MessageType::ERROR,
          buttons_type: Gtk::ButtonsType::OK,
          message: 'Error'
        )
        .and_wrap_original do |_method, *_args|
          dialog_mock = instance_double(Gtk::MessageDialog)
          allow(dialog_mock).to receive(:secondary_text=)
          allow(dialog_mock).to receive(:run)
          allow(dialog_mock).to receive(:destroy)
          dialog_mock
        end

      instance.send(:show_error_dialog, message)
    end

    it 'sets secondary text to message' do
      message = 'Test error message'
      dialog_mock = instance_double(Gtk::MessageDialog)
      allow(Gtk::MessageDialog).to receive(:new).and_return(dialog_mock)
      allow(dialog_mock).to receive(:run)
      allow(dialog_mock).to receive(:destroy)

      expect(dialog_mock).to receive(:secondary_text=).with(message)

      instance.send(:show_error_dialog, message)
    end

    it 'runs and destroys dialog' do
      dialog_mock = instance_double(Gtk::MessageDialog)
      allow(Gtk::MessageDialog).to receive(:new).and_return(dialog_mock)
      allow(dialog_mock).to receive(:secondary_text=)

      expect(dialog_mock).to receive(:run)
      expect(dialog_mock).to receive(:destroy)

      instance.send(:show_error_dialog, 'Test')
    end
  end

  describe 'category detection' do
    let(:instance) { described_class.new }

    context 'uppercase detection' do
      it 'detects uppercase letters' do
        password = 'Abc'
        expect(password).to match(/[A-Z]/)
      end

      it 'does not detect lowercase as uppercase' do
        password = 'abc'
        expect(password).not_to match(/[A-Z]/)
      end
    end

    context 'lowercase detection' do
      it 'detects lowercase letters' do
        password = 'aBc'
        expect(password).to match(/[a-z]/)
      end

      it 'does not detect uppercase as lowercase' do
        password = 'ABC'
        expect(password).not_to match(/[a-z]/)
      end
    end

    context 'number detection' do
      it 'detects numeric digits' do
        password = 'abc1'
        expect(password).to match(/[0-9]/)
      end

      it 'does not detect letters as numbers' do
        password = 'abc'
        expect(password).not_to match(/[0-9]/)
      end
    end

    context 'special character detection' do
      it 'detects common special characters' do
        special_chars = '!@#$%^&*-_=+[]{}' + "';:\"" + '<>?,./\\|`~'
        special_chars.each_char do |char|
          expect(char).to match(/[!@#$%^&*\-_=+\[\]{};:'",.<>?\/\\|`~]/)
        end
      end
    end
  end

  describe 'length calculation' do
    let(:instance) { described_class.new }

    it 'correctly counts password length' do
      passwords = ['', 'a', 'ab', 'abc', 'abcdefghij', 'a' * 100]
      passwords.each do |pwd|
        expect(pwd.length).to eq(pwd.length)
      end
    end

    it 'handles unicode length correctly' do
      password = 'ÐŸÐ°Ñ€Ð¾Ð»ÑŒå¯†ç ðŸ”'
      expect(password.length).to be > 0
    end

    it 'counts special characters in length' do
      password = 'Pass!@#$%'
      expect(password.length).to eq(9)
    end
  end

  describe 'dialog structure' do
    let(:instance) { described_class.new }

    it 'creates modal dialog' do
      allow(Gtk::Dialog).to receive(:new).and_wrap_original do |_method, *_args|
        dialog_mock = instance_double(Gtk::Dialog)
        allow(dialog_mock).to receive(:set_default_size)
        allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
        allow(dialog_mock).to receive(:show_all)
        allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::CANCEL)
        allow(dialog_mock).to receive(:destroy)
        dialog_mock
      end

      expect(Gtk::Dialog).to(
        receive(:new)
          .with(
            title: "Create Master Password",
            parent: nil,
            flags: Gtk::Dialog::MODAL,
            buttons: [
              [Gtk::Stock::OK, Gtk::ResponseType::OK],
              [Gtk::Stock::CANCEL, Gtk::ResponseType::CANCEL]
            ]
          )
          .and_wrap_original { |_method, *_args|
            dialog_mock = instance_double(Gtk::Dialog)
            allow(dialog_mock).to receive(:set_default_size)
            allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
            allow(dialog_mock).to receive(:show_all)
            allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::CANCEL)
            allow(dialog_mock).to receive(:destroy)
            dialog_mock
          }
      )

      instance.show_dialog
    end

    it 'sets dialog size' do
      dialog_mock = instance_double(Gtk::Dialog)
      allow(Gtk::Dialog).to receive(:new).and_return(dialog_mock)
      allow(dialog_mock).to receive(:child).and_return(instance_double(Gtk::Box))
      allow(dialog_mock).to receive(:show_all)
      allow(dialog_mock).to receive(:run).and_return(Gtk::ResponseType::CANCEL)
      allow(dialog_mock).to receive(:destroy)

      expect(dialog_mock).to receive(:set_default_size).with(500, 450)

      instance.show_dialog
    end
  end
end
