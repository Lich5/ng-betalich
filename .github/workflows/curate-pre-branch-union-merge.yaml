name: Curate Pre Branch (Cherry-pick PRs)
# =============================================================================
# Purpose: Curate a prerelease branch (e.g., pre/beta or pre/beta/<slug>) from
#          a clean base, then cherry-pick or squash-merge selected PRs for
#          prerelease testing with optional automated conflict resolution.
#
# Design Philosophy:
#   - Fail-safe by default: Unknown conflicts abort (conflict_strategy=abort)
#   - Explicit opt-in for risky operations (reset_destination, union merge)
#   - Guard rails prevent catastrophic mistakes (targeting main, path traversal)
#   - Testability via dry-run mode before live execution
#   - Observability through detailed logging and GitHub annotations
#
# Workflow Behavior:
#   1. Validates and normalizes all inputs (guards against injection/typos)
#   2. Creates or updates destination branch from base
#   3. Cherry-picks each PR in order, handling conflicts per strategy
#   4. Validates syntax of modified files (when conflicts resolved automatically)
#   5. Pushes result to remote (or previews in dry-run mode)
#   6. Reports detailed summary with actionable next steps
#
# Footguns Explicitly Guarded:
#   - Targeting 'main' branch (blocked - would pollute trunk)
#   - Using base other than 'main' (blocked - enforces single source of truth)
#   - Non-pre/beta destinations (normalized or blocked - prevents mistakes)
#   - Unsafe destination names with ../ or whitespace (blocked - path traversal)
#   - History destruction (opt-in via reset_destination=true with confirmation)
#   - Silent conflict auto-resolution (opt-in via conflict_strategy=both + warnings)
#   - Pushing broken code (syntax validation required after union merge)
#
# Input Parameters Explained:
#   - destination: Target branch name (auto-prefixed with pre/beta/ if needed)
#   - base: Source branch (MUST be 'main', ensures consistent starting point)
#   - prs: Comma-separated PR numbers (e.g., "12,27,43" - order matters!)
#   - mode: How to source commits:
#       * auto: Use merge commit if PR is merged, else use head (smart default)
#       * merged: Force use of merge commit (fails if PR not merged)
#       * head: Always use PR head (ignores merge commits, for open PRs)
#   - squash: Collapse multi-commit PRs into single commit? (true/false)
#       * true: Clean history, single commit per PR with descriptive message
#       * false: Preserves full PR commit history (useful for detailed tracking)
#   - conflict_strategy: How to handle merge conflicts:
#       * abort: Stop on conflicts (SAFE DEFAULT - requires manual resolution)
#       * ours: Auto-resolve favoring current branch (use cautiously)
#       * theirs: Auto-resolve favoring incoming PR (use cautiously)
#       * both: Union merge - keeps BOTH sides (EXPERIMENTAL - see warnings below)
#   - reset_destination: Discard existing branch history? (true/false)
#       * true: Force-recreate branch from base (DESTRUCTIVE - loses history)
#       * false: Preserve existing commits, append new PRs (safer for iteration)
#   - dry_run: Preview without pushing? (true/false)
#       * true: Execute locally, show results, don't push (SAFE for testing)
#       * false: Push to remote (live operation)
#
# âš ï¸  EXPERIMENTAL FEATURE: Union Merge (conflict_strategy=both)
#     ------------------------------------------------------------------------
#     What it does:
#       - When conflicts occur, automatically concatenates BOTH versions
#       - Uses Git's 3-way merge stages (:2: = ours, :3: = theirs)
#       - Stages result and continues operation without failing
#
#     Why it's dangerous:
#       - No semantic understanding of code (syntax-blind concatenation)
#       - Creates duplicates (methods, variables, imports, config values)
#       - May produce syntactically valid but logically broken code
#       - Cannot detect contradictory logic (e.g., API_URL set twice)
#
#     When it might work:
#       âœ“ CHANGELOG entries (append-only, order doesn't matter)
#       âœ“ Gemfile additions (independent gems, unlikely duplicates)
#       âœ“ Documentation with non-overlapping sections
#
#     When it WILL break:
#       âœ— Method definitions (duplicate def = SyntaxError)
#       âœ— Configuration values (last assignment wins = silent bugs)
#       âœ— Import statements (duplicate requires = warnings/errors)
#       âœ— Conditional logic (both branches kept = nonsense code)
#
#     Safety nets in place:
#       1. Syntax validation runs after resolution (Ruby/YAML/JSON)
#       2. Detailed conflict log with file previews in GitHub Summary
#       3. Warning annotations on every conflicted file
#       4. Manual review reminder in job output
#       5. Dry-run mode to preview before live execution
#
#     Recommended workflow:
#       1. Test with dry_run=true first
#       2. Review conflict log carefully
#       3. If acceptable, run with dry_run=false
#       4. Manually review all conflicted files
#       5. Run full test suite before deploying
#
# Known Limitations:
#   - Syntax validation only catches parse errors, not semantic bugs
#   - No support for interactive conflict resolution
#   - Union merge for binary files falls back to 'theirs' strategy
#   - Concurrent runs on same destination may conflict (mitigated by concurrency group)
#   - GitHub API rate limits apply (60 req/hr unauthenticated, 5000/hr authenticated)
#
# Maintenance Notes:
#   - Keep guard steps separate for clarity (even if redundant - defense in depth)
#   - Preserve detailed comments - this workflow is complex and risky
#   - Test changes with dry_run before modifying live workflow
#   - Union merge resolver is in-line (lines 170-250) - modify carefully
#   - If adding file type syntax checks, add to validation step (lines 460-490)
#
# Related Workflows:
#   - prepare-prerelease.yaml: Next step after this workflow completes
#   - guard-pre-branch-pr.yaml: Prevents pre/* branches merging to main
#   - cherry-pick-to-pre.yaml: Original baseline (no union merge support)
#
# Exit Codes:
#   0 = Success (all PRs cherry-picked, no conflicts or resolved successfully)
#   1 = Failure (validation failed, conflicts unresolved, push failed, syntax errors)
# =============================================================================

on:
  workflow_dispatch:
    inputs:
      destination:
        description: "Destination pre branch (e.g., pre/beta)"
        required: true
        default: "pre/beta"
      base:
        description: "Base branch to start from"
        required: true
        default: "main"
      prs:
        description: "Comma-separated PR numbers to include (e.g., 12,27,43)"
        required: true
      mode:
        description: "auto | merged | head (how to source commits)"
        required: true
        default: "auto"
      squash:
        description: "Squash multi-commit PRs into one commit on the pre branch? (true/false)"
        required: true
        default: "true"
      conflict_strategy:
        description: "abort | ours | theirs | both (EXPERIMENTAL: union merge)"
        required: true
        default: "abort"
      reset_destination:
        description: "Force-create destination from base (discard existing history)? (true/false)"
        required: true
        default: "false"
      dry_run:
        description: "Preview changes without pushing? (true/false)"
        required: true
        default: "false"

# Permissions: Minimal required scope following principle of least privilege
permissions:
  contents: write       # Required: Create branches, tags, commits, and push
  pull-requests: read   # Required: Fetch PR metadata via GitHub API

# Concurrency control: Prevent simultaneous curation of same destination branch
# Why: Concurrent cherry-picks to same branch cause race conditions and conflicts
# cancel-in-progress: true means newer run cancels older (latest intent wins)
concurrency:
  group: curate-${{ github.ref }}-${{ github.event.inputs.destination }}
  cancel-in-progress: true

jobs:
  curate:
    runs-on: ubuntu-latest
    steps:
      # =========================================================================
      # SETUP: Checkout and tool installation
      # =========================================================================
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          # fetch-depth: 0 is CRITICAL - we need full history for:
          #   - Cherry-picking commits by SHA
          #   - Merge-base calculations
          #   - Tag resolution
          #   - Accurate git log output
          fetch-depth: 0

      # =========================================================================
      # GUARD RAILS: Input validation and normalization
      # =========================================================================
      # Why separate guard steps?
      #   - Defense in depth: Multiple checks catch edge cases
      #   - Clear failure messages: Each guard explains what went wrong
      #   - Easy to audit: Grep for "Guard" to see all safety checks
      #   - Maintainability: Add new guards without touching core logic

      - name: Guard validate destination and base
        id: guard_validate
        shell: bash
        env:
          RAW_DEST: ${{ inputs.destination }}
          RAW_BASE: ${{ inputs.base }}
        run: |
          set -euo pipefail  # Fail on: errors, undefined vars, pipe failures

          # Helper: Print error and exit
          # Why function? Consistent error formatting with GitHub annotations
          die(){ echo "::error::$*"; exit 1; }

          # Helper: Normalize branch names
          # Purpose: Strip refs/heads/, remove whitespace, trim trailing slashes
          # Why? Users may copy branch names from various sources with different formats
          # Examples:
          #   "refs/heads/pre/beta" â†’ "pre/beta"
          #   "  pre/beta  " â†’ "pre/beta"
          #   "pre/beta/" â†’ "pre/beta"
          norm(){ local s="$1"; s="${s#refs/heads/}"; s="$(echo "$s" | tr -d '[:space:]')"; s="${s%/}"; echo "$s"; }

          DEST="$(norm "$RAW_DEST")"
          BASE="$(norm "$RAW_BASE")"

          # GUARD: Base must be 'main'
          # Why? Enforces single source of truth for release trains
          # Prevents: Prerelease from arbitrary branches causing version confusion
          case "$BASE" in
            main) ;;
            *) die "Invalid base '$BASE'. Only 'main' is allowed." ;;
          esac

          # GUARD: Destination must not contain path traversal or whitespace
          # Why? Prevents directory traversal attacks and git command injection
          # Blocks: "../main", "pre/beta/../main", "pre beta" (with space)
          if [[ "$DEST" =~ (\.\.|[[:space:]]) ]]; then
            die "Destination '$DEST' contains illegal sequences."
          fi

          # NORMALIZATION: Auto-prefix with pre/beta/ if not already present
          # Why? User convenience - "my-feature" becomes "pre/beta/my-feature"
          # Allows explicit "pre/beta" or "pre/beta/slug" while catching typos
          if [[ "$DEST" != pre/beta && "$DEST" != pre/beta/* ]]; then
            # Check if destination looks like a valid slug (alphanum, dots, dashes, slashes)
            if [[ "$DEST" =~ ^[A-Za-z0-9._-]+(/[A-Za-z0-9._-]+)*$ ]]; then
              echo "Shaping '$DEST' => 'pre/beta/$DEST'"
              DEST="pre/beta/$DEST"
            else
              die "Destination '$DEST' must be 'pre/beta' or 'pre/beta/<slug>'."
            fi
          fi

          # Export sanitized values to BOTH:
          #   - GITHUB_ENV: Available to subsequent steps as env vars
          #   - GITHUB_OUTPUT: Available to subsequent steps as step outputs
          # Why both? Defensive programming - different steps may use different access patterns
          printf 'DEST_SAFE=%s\n' "$DEST" >> "$GITHUB_ENV"
          printf 'BASE_SAFE=%s\n' "$BASE" >> "$GITHUB_ENV"
          printf 'dest_safe=%s\n' "$DEST" >> "$GITHUB_OUTPUT"
          printf 'base_safe=%s\n' "$BASE" >> "$GITHUB_OUTPUT"

      - name: "Guard: refuse to curate into main"
        shell: bash
        env:
          DEST_SAFE: ${{ steps.guard_validate.outputs.dest_safe }}
        run: |
          # GUARD: Never allow curation into 'main' branch
          # Why? Main is protected trunk - should only receive tested releases
          # Redundant with normalization above? Yes - defense in depth
          # Edge case caught: User somehow bypasses normalization logic
          if [ "$DEST_SAFE" = "main" ]; then
            echo "::error::Refusing to curate into 'main'."
            exit 1
          fi

      - name: Guard validate PR list
        shell: bash
        env:
          RAW_PRS: ${{ inputs.prs }}
        run: |
          set -euo pipefail

          # GUARD: PR list must not be empty
          # Why? Workflow is meaningless without PRs to cherry-pick
          if [ -z "$RAW_PRS" ]; then
            echo "::error::'prs' input is required"; exit 1
          fi

          # GUARD: PR list must be comma-separated digits only
          # Why? Prevents injection attacks and catches user typos
          # Valid: "12,27,43" or "12, 27, 43" (spaces OK)
          # Invalid: "12;rm -rf /" or "PR-12" or "abc,def"
          if ! printf '%s' "$RAW_PRS" | grep -Eq '^[0-9]+( *[,]+ *[0-9]+)*$'; then
            echo "::error::'prs' must be a comma-separated list of PR numbers (digits only)"; exit 1
          fi

          # NORMALIZATION: Remove spaces and deduplicate PR numbers
          # Why spaces? User convenience - "12, 27, 43" is easier to read than "12,27,43"
          # Why dedupe? If user accidentally lists "12,27,12", cherry-pick 12 only once
          # Algorithm: awk splits by comma, tracks seen numbers, builds unique ordered list
          PRS_SAFE="$(printf '%s' "$RAW_PRS" | tr -d ' ' | awk -F, '{
            n=split($0,a,","); delete seen; out="";
            for(i=1;i<=n;i++){ if(!(a[i] in seen)){ seen[a[i]]=1; out=(out?out",":""); out=out a[i]; } }
            print out }')"
          printf 'PRS_SAFE=%s\n' "$PRS_SAFE" >> "$GITHUB_ENV"

      # =========================================================================
      # DEPENDENCIES: Ensure required tools are available
      # =========================================================================
      - name: Ensure required tools
        run: |
          # jq is required for JSON parsing (GitHub API responses, config files)
          # Why check? ubuntu-latest includes jq, but defensive programming
          # Why apt-get? Ensures workflow doesn't fail if runner image changes
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -qq
            sudo apt-get install -y jq
          fi

      # =========================================================================
      # GIT CONFIGURATION: Set identity for commits
      # =========================================================================
      - name: Configure bot identity
        run: |
          # All commits created by this workflow use the github-actions bot identity
          # Why? Clear attribution in git log, distinguishes automated vs manual commits
          # Why this specific email? GitHub's official bot user ID
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # =========================================================================
      # CONFLICT TRACKING: Initialize state for logging
      # =========================================================================
      - name: Initialize conflict tracking
        run: |
          # CONFLICT_LOG_FILE: Temporary file to accumulate conflict details
          # Why temp file? Bash heredocs in GitHub Actions are awkward for multi-step accumulation
          # HAD_CONFLICTS: Boolean flag to trigger validation and warnings
          # Why env var? Persists across steps, enables conditional logic
          echo "CONFLICT_LOG_FILE=$(mktemp)" >> "$GITHUB_ENV"
          echo "HAD_CONFLICTS=false" >> "$GITHUB_ENV"

      # =========================================================================
      # UNION MERGE RESOLVER: Create executable script for conflict resolution
      # =========================================================================
      # Why separate script?
      #   - Reusability: Called multiple times (base sync, each PR cherry-pick)
      #   - Testability: Can be extracted and unit-tested independently
      #   - Readability: Separates complex logic from main workflow
      #   - Maintainability: Single source of truth for union merge algorithm
      - name: Create union merge resolver script
        shell: bash
        run: |
          cat > "$RUNNER_TEMP/union-resolve.sh" <<'RESOLVER_EOF'
          #!/usr/bin/env bash
          # =======================================================================
          # union-resolve.sh - Implements union merge conflict resolution
          # =======================================================================
          # Purpose: Automatically resolve git conflicts by keeping BOTH sides
          #
          # Algorithm:
          #   1. Detect conflicted files via git diff --name-only --diff-filter=U
          #   2. For each file with 3-way merge info available:
          #        a. Extract :2: (ours/current branch version)
          #        b. Extract :3: (theirs/incoming PR version)
          #        c. Concatenate both versions into working tree file
          #        d. Stage resolved file with git add
          #        e. Log file path and preview to conflict log
          #   3. Set HAD_CONFLICTS=true to trigger validation step
          #   4. Return 0 (success) so caller can continue cherry-pick/merge
          #
          # Git's 3-Way Merge Stages:
          #   :1:<file> = common ancestor (merge base)
          #   :2:<file> = ours (current branch, "HEAD")
          #   :3:<file> = theirs (incoming change, "MERGE_HEAD")
          #
          # Why concatenation?
          #   - Simplest union operation that preserves all code
          #   - Works for append-only files (CHANGELOG, some configs)
          #   - Fails safely (usually syntax error) rather than silently
          #
          # Why this is dangerous:
          #   - No understanding of code structure (methods, variables, logic)
          #   - Creates duplicates that may be syntactically valid but wrong
          #   - Examples of breakage:
          #       * "def foo; ...; end" + "def foo; ...; end" = SyntaxError (duplicate method)
          #       * "API_URL='A'" + "API_URL='B'" = Last wins (silent logic bug)
          #       * "require 'x'" + "require 'x'" = Warning but works (minor)
          #
          # Fallback behavior:
          #   - If :1: (common ancestor) doesn't exist: use 'theirs' strategy
          #   - Why? New file added in both branches, no merge base to compare
          #   - Limitation: Loses 'ours' version in this case (documented trade-off)
          #
          # Parameters:
          #   $1 (pr_context) - Optional PR number for logging (e.g., "42")
          #                     If provided, logs "Conflict Resolution: PR #42"
          #                     If empty, caller should provide context separately
          #
          # Side Effects:
          #   - Modifies working tree files in-place
          #   - Stages files with git add
          #   - Writes to $CONFLICT_LOG_FILE (must be set by caller)
          #   - Sets HAD_CONFLICTS=true in $GITHUB_ENV
          #
          # Exit Codes:
          #   0 = Success (conflicts resolved, or no conflicts detected)
          #   Never fails - caller must validate result
          # =======================================================================

          resolve_conflicts_both() {
            local pr_context="${1:-}"
            local conflicts

            # Detect files with unresolved conflicts
            # --name-only: Just file paths, not diff content
            # --diff-filter=U: U = unmerged (conflicted) files only
            conflicts="$(git diff --name-only --diff-filter=U 2>/dev/null || true)"

            if [ -z "$conflicts" ]; then
              # No conflicts detected - this is OK, means conflict resolved elsewhere or didn't occur
              echo "No conflicts detected during resolution attempt."
              return 0
            fi

            # Set global flag to trigger validation and warnings
            echo "HAD_CONFLICTS=true" >> "$GITHUB_ENV"

            # Write section header to conflict log (only if PR context provided)
            # Why conditional? Base sync doesn't have PR number, handled by caller
            if [ -n "$pr_context" ]; then
              {
                echo ""
                echo "## ðŸ”€ Conflict Resolution: PR #${pr_context}"
                echo ""
                echo "### Files with conflicts (union merged):"
              } >> "$CONFLICT_LOG_FILE"
            fi

            # Process each conflicted file
            local file
            while IFS= read -r file; do
              [ -z "$file" ] && continue  # Skip empty lines

              echo "  Resolving conflict in: $file"
              echo "- \`$file\`" >> "$CONFLICT_LOG_FILE"

              # Attempt 3-way merge resolution
              # Check if :1: (common ancestor) exists - indicates 3-way merge available
              if git show :1:"$file" > /dev/null 2>&1; then
                # 3-way merge available: we can extract both sides

                # Save both versions with conflict markers for auditing
                # Why save? Allows manual review to see what was merged
                # File: <original>.union-merge (kept for debugging)
                {
                  echo "<<<<<<< OURS (current branch)"
                  git show :2:"$file" 2>/dev/null || echo "(deleted in ours)"
                  echo "======="
                  git show :3:"$file" 2>/dev/null || echo "(deleted in theirs)"
                  echo ">>>>>>> THEIRS (incoming changes)"
                } > "${file}.union-merge"

                # Perform union merge: concatenate ours + theirs
                # Order matters: ours first, then theirs (preserves context for most cases)
                # Why this order? If one side is a no-op, starting with current state is safer
                {
                  git show :2:"$file" 2>/dev/null || true
                  git show :3:"$file" 2>/dev/null || true
                } > "$file"
              else
                # No common ancestor - fallback to 'theirs' strategy
                # Why 'theirs'? New file added in both branches, incoming version likely more complete
                # Limitation: Loses 'ours' version - acceptable trade-off for rare case
                # Alternative considered: Concatenate without merge base (rejected - too unpredictable)
                git checkout --theirs "$file" 2>/dev/null || true
              fi

              # Stage the resolved file
              # Why stage here? Allows git cherry-pick --continue to proceed automatically
              git add "$file"

              # Log preview of resolved file to conflict log
              # Why first 20 lines? Balance between useful preview and log size
              # Why head? If file is huge, don't spam the log
              {
                echo ""
                echo "  **Location preview:**"
                echo '  ```'
                head -n 20 "$file" 2>/dev/null || echo "  (binary or unreadable file)"
                echo '  ```'
                echo ""
              } >> "$CONFLICT_LOG_FILE"
            done <<< "$conflicts"

            # Summary output for workflow logs
            echo "Union merge completed for $(echo "$conflicts" | wc -l) file(s)"
            return 0
          }
          RESOLVER_EOF

          # Make script executable
          # Why chmod? Script is sourced, not executed, but good practice for portability
          chmod +x "$RUNNER_TEMP/union-resolve.sh"

      # =========================================================================
      # BRANCH PREPARATION: Create or update destination branch
      # =========================================================================
      # Behavior matrix:
      #   reset_destination=true:
      #     - Force-create branch from base (destroys existing history)
      #     - Use case: Start fresh, discard previous curation attempts
      #
      #   reset_destination=false + branch doesn't exist:
      #     - Create new branch from base
      #     - Use case: First curation of this prerelease train
      #
      #   reset_destination=false + branch exists:
      #     - Checkout existing branch
      #     - Sync with base via no-ff merge (preserves train history)
      #     - If conflicts during sync:
      #         * conflict_strategy=both: Auto-resolve via union merge
      #         * Otherwise: Abort and fail workflow
      #     - Use case: Iterative curation, adding more PRs to existing train
      - name: Prepare destination branch
        env:
          DEST: ${{ steps.guard_validate.outputs.dest_safe }}
          BASE: ${{ steps.guard_validate.outputs.base_safe }}
          RESET: ${{ inputs.reset_destination }}
          STRAT: ${{ inputs.conflict_strategy }}
        run: |
          set -euo pipefail

          # Fetch latest base branch from remote
          # Why? Ensures we're working with current main, not stale local copy
          git fetch origin "$BASE"

          if [ "$RESET" = "true" ]; then
            # DESTRUCTIVE PATH: Force-create branch from base
            # -B flag: Create if doesn't exist, reset if exists
            # Why origin/$BASE? Ensures we use remote state, not local
            git checkout -B "$DEST" "origin/$BASE"
          else
            # INCREMENTAL PATH: Preserve existing branch or create new

            if git ls-remote --exit-code --heads origin "$DEST" >/dev/null 2>&1; then
              # Branch exists on remote - check it out and sync with base
              git fetch origin "$DEST"
              git checkout "$DEST"

              # Sync destination with base using no-ff merge
              # Why --no-ff? Creates merge commit preserving prerelease train ancestry
              # Why --no-edit? Use default merge message (can be overridden in git config)
              # What if this conflicts? Two scenarios:
              #   1. Divergent changes in base that conflict with curated PRs
              #   2. Base has been updated since last curation
              git merge --no-ff --no-edit "origin/$BASE" || {
                # Merge failed - detect if conflicts or other error
                conflicts="$(git diff --name-only --diff-filter=U || true)"
                echo "::group::Merge conflicts while syncing $DEST with origin/$BASE"

                if [ -n "$conflicts" ]; then
                  # Real conflicts detected during base sync

                  # Emit file-level warnings for GitHub UI annotations
                  # Why per-file? Allows clicking file name in UI to see conflict
                  while IFS= read -r f; do
                    [ -n "$f" ] && echo "::warning file=$f::merge conflict in $f"
                  done <<< "$conflicts"

                  # Write summary to GitHub step summary (visible in UI)
                  {
                    echo "### Merge conflicts detected while syncing \`$DEST\` with \`origin/$BASE\`"
                    printf '%s\n' "$conflicts" | awk '{print "- " $0}'
                  } >> "$GITHUB_STEP_SUMMARY"

                  # Decision point: Auto-resolve or fail?
                  if [ "$STRAT" = "both" ] && [ -n "$conflicts" ]; then
                    # User opted into union merge - attempt auto-resolution
                    echo "HAD_CONFLICTS=true" >> "$GITHUB_ENV"

                    # Write context header to conflict log
                    # Why separate from resolver function? Base sync has different context than PR
                    {
                      echo "## ðŸ”€ Base Sync Conflict Resolution (Union Merge)"
                      echo "**Operation:** Syncing \`$DEST\` with \`origin/$BASE\`"
                      echo ""
                      echo "### Files with conflicts:"
                    } >> "$CONFLICT_LOG_FILE"

                    # Source and call union merge resolver
                    # shellcheck source=/dev/null
                    . "$RUNNER_TEMP/union-resolve.sh"
                    resolve_conflicts_both  # No PR context for base sync

                    # Commit the union-merged result
                    # --no-edit: Keep default merge message with note about resolution
                    git commit --no-edit -m "chore: sync base (union merge via workflow)"
                  else
                    # User wants manual conflict resolution or used abort strategy
                    git merge --abort || true
                    echo "::error::Merge conflicts detected. Use conflict_strategy=both to auto-resolve or fix manually."
                    exit 1
                  fi
                else
                  # Merge failed but no conflicts detected - this is unusual
                  # Possible causes: git bug, file permissions, disk full, network issue
                  echo "::warning::Merge failed but no conflicted files detected."
                  git merge --abort || true
                  exit 1
                fi

                echo "::endgroup::"
              }
            else
              # Branch doesn't exist on remote - create new from base
              git checkout -B "$DEST" "origin/$BASE"
            fi
          fi

      # =========================================================================
      # PRERELEASE TAG: Mark the base commit for Release Please
      # =========================================================================
      # This ephemeral tag is force-updated to point at the chosen base for this train.
      # Purpose: Release Please uses this to calculate commits since last release
      # Why force-push? Tag moves as base advances (e.g., main gets new commits)
      # Tag format: prebeta-base/<destination> (e.g., prebeta-base/pre/beta/my-feature)
      # Lifecycle: Created here, consumed by prepare-prerelease.yaml, persists until train merged
      - name: Create prerelease base tag
        shell: bash
        env:
          DEST: ${{ steps.guard_validate.outputs.dest_safe }}
          BASE: ${{ steps.guard_validate.outputs.base_safe }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail

          # Fetch all tags to avoid conflicts with existing tags
          git fetch --tags origin

          # Resolve base to SHA (not symbolic ref)
          # Why? Tag must point to commit, not branch (branches move, tags are stable)
          BASE_SHA=$(git rev-parse "origin/${BASE}")

          # Construct tag name specific to this destination
          # Why per-destination? Multiple prerelease trains can exist simultaneously
          TAG="prebeta-base/${DEST}"

          echo "Tagging $TAG at $BASE_SHA"

          # Force-create tag (overwrites if exists)
          # -f: Force flag allows tag to move
          # Why move? Base branch (main) advances over time, tag should track it
          git tag -f "$TAG" "$BASE_SHA"

          # Push tag to remote (unless dry-run)
          if [ "$DRY_RUN" != "true" ]; then
            # -f: Force push (remote tag will be overwritten)
            # Why force? Tag is ephemeral and expected to move
            git push -f origin "refs/tags/$TAG"
          else
            echo "[DRY-RUN] Would push tag: $TAG"
          fi

      # =========================================================================
      # CHERRY-PICK LOOP: Apply PRs to destination branch
      # =========================================================================
      # This is the core logic of the workflow. For each PR in the list:
      #   1. Fetch PR metadata from GitHub API (state, merge_commit_sha, title)
      #   2. Decide which commit(s) to cherry-pick based on mode:
      #        - mode=merged or (mode=auto + PR is merged): Use merge commit
      #        - mode=head or (mode=auto + PR is open): Use PR head commit(s)
      #   3. Perform cherry-pick or squash-merge based on squash parameter
      #   4. Handle conflicts according to conflict_strategy
      #   5. Amend commit message to include PR number trailer
      #   6. Continue to next PR
      #
      # Conflict resolution flow:
      #   - If cherry-pick/merge succeeds: Continue normally
      #   - If cherry-pick/merge fails:
      #       * conflict_strategy=abort: Fail workflow (default)
      #       * conflict_strategy=ours/theirs: Use git's -X strategy
      #       * conflict_strategy=both: Call resolve_conflicts_both(), continue
      #
      # Error handling:
      #   - ERR trap: On any error, abort in-progress operations and fail workflow
      #   - Why? Prevents partial state (e.g., half-cherry-picked PR)
      - name: Cherry-pick PRs with conflict resolution
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          DEST: ${{ steps.guard_validate.outputs.dest_safe }}
          PRS:  ${{ inputs.prs }}
          MODE: ${{ inputs.mode }}
          SQUASH: ${{ inputs.squash }}
          STRAT: ${{ inputs.conflict_strategy }}
        shell: bash
        run: |
          set -euo pipefail

          # Map conflict strategy to git flags and behavior flag
          # XFLAG: Passed to git cherry-pick/merge (e.g., "-X ours")
          # USE_BOTH: Boolean flag to enable union merge logic
          case "$STRAT" in
            ours)
              # -X ours: On conflict, automatically prefer current branch version
              # Use case: Overriding PR changes with existing code
              XFLAG="-X ours"
              USE_BOTH=0
              ;;
            theirs)
              # -X theirs: On conflict, automatically prefer incoming PR version
              # Use case: Accepting PR changes over existing code
              XFLAG="-X theirs"
              USE_BOTH=0
              ;;
            both)
              # No -X flag: We handle conflicts manually via union merge
              # Why no -X? We want git to report conflicts, not auto-resolve
              XFLAG=""
              USE_BOTH=1
              ;;
            *)
              # Default (abort): No -X flag, let git cherry-pick fail on conflicts
              XFLAG=""
              USE_BOTH=0
              ;;
          esac

          # GitHub API helper function
          # Why function? Encapsulates auth and headers for consistency
          # Parameters: Any valid curl arguments (e.g., URL, -X POST, -d data)
          api() {
            curl -sS \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$@"
          }

          # Source union merge resolver script
          # Why source? Loads resolve_conflicts_both() function into current shell
          # shellcheck source=/dev/null
          . "$RUNNER_TEMP/union-resolve.sh"

          # Wrapper function: Execute git command with optional conflict resolution
          # Purpose: DRY principle - don't repeat conflict handling logic for each cherry-pick
          # Parameters:
          #   $1 (pr_context): PR number for logging (e.g., "42")
          #   $2 (continue_cmd): Command to continue operation after resolution (e.g., "git cherry-pick --continue")
          #   $3+ (command): The git command to execute (e.g., git cherry-pick -x <sha>)
          # Behavior:
          #   - Runs command, captures exit status
          #   - If success (status=0): Return normally
          #   - If failure (status!=0):
          #       * USE_BOTH=1: Call resolve_conflicts_both, then continue_cmd
          #       * USE_BOTH=0: Propagate failure to caller
          run_with_conflict_resolution() {
            local pr_context="$1"
            local continue_cmd="$2"
            shift 2  # Remove first two args, leaving command in $@

            # Temporarily disable exit-on-error to capture status
            set +e
            "$@"
            local status=$?
            set -e

            if [ $status -ne 0 ]; then
              # Command failed - conflict or other error

              if [ "$USE_BOTH" -eq 1 ]; then
                # Union merge enabled - attempt auto-resolution
                echo "Conflict detected, applying union merge strategy..."
                resolve_conflicts_both "$pr_context"

                # If continue command specified (e.g., "git cherry-pick --continue"), run it
                if [ -n "$continue_cmd" ]; then
                  eval "$continue_cmd" || {
                    echo "::error::Failed to continue after conflict resolution"
                    exit 1
                  }
                fi
              else
                # Union merge disabled - propagate error to caller
                echo "::error::Command failed with status $status"
                return $status
              fi
            fi
            # Success path: Command succeeded or was resolved, continue normally
          }

          # Helper: Ensure commit message ends with PR number trailer
          # Purpose: Links commits back to originating PR for traceability
          # Format: "feat: add feature (#42)" or "fix: bug fix (#42)"
          # Why? GitHub auto-links #42 to PR, useful in git log and blame
          # Parameters:
          #   $1 (title): PR title (e.g., "feat: add feature")
          #   $2 (pr): PR number (e.g., "42")
          # Returns: Title with (#PR) appended if not already present
          with_pr_trailer() {
            local title="$1" pr="$2"
            # Check if title already ends with (#number) or #number)
            # Why check? PR may already have trailer, avoid "feat: foo (#42) (#42)"
            if printf '%s' "$title" | grep -Eq '\(#?[0-9]+\)$'; then
              printf '%s\n' "$title"  # Already has trailer, return as-is
            else
              printf '%s (#%s)\n' "$title" "$pr"  # Append trailer
            fi
          }

          # Main cherry-pick loop
          # Process: Split comma-separated PR list, iterate over each PR
          LIST="${PRS_SAFE:-$PRS}"  # Use normalized list if available, else raw
          IFS=',' read -ra ARR <<< "$LIST"  # Split into array

          for N in "${ARR[@]}"; do
            N=$(echo "$N" | xargs)  # Trim whitespace (defensive)
            echo "::group::PR #$N"   # Collapsible section in GitHub logs

            # Fetch PR metadata from GitHub API
            # API endpoint: GET /repos/{owner}/{repo}/pulls/{pull_number}
            # Response: JSON with state, merged, merge_commit_sha, title, etc.
            PR_JSON=$(api "https://api.github.com/repos/$REPO/pulls/$N")

            # Extract fields using jq (JSON parser)
            STATE=$(echo "$PR_JSON"     | jq -r '.state')          # "open" or "closed"
            MERGED=$(echo "$PR_JSON"    | jq -r '.merged')         # true if PR was merged
            MERGE_SHA=$(echo "$PR_JSON" | jq -r '.merge_commit_sha')  # SHA of merge commit (null if not merged)
            TITLE=$(echo "$PR_JSON"     | jq -r '.title')          # PR title (for commit message)

            # Construct commit subject with PR trailer
            SUBJECT=$(with_pr_trailer "$TITLE" "$N")

            # ===================================================================
            # BRANCH 1: Use merge commit (if PR is merged and mode allows)
            # ===================================================================
            # Conditions:
            #   - mode=merged (explicit: force use merge commit)
            #   - mode=auto AND PR is merged AND merge_commit_sha exists
            # Why prefer merge commit?
            #   - Preserves original merge structure
            #   - Includes merge conflict resolutions from PR merge
            #   - Single commit represents entire PR (clean prerelease history)
            if [ "$MODE" = "merged" ] || { [ "$MODE" = "auto" ] && [ "$MERGED" = "true" ] && [ "$MERGE_SHA" != "null" ]; }; then
              echo "Cherry-picking MERGED PR #$N commit $MERGE_SHA"

              # Cherry-pick merge commit with conflict resolution support
              # -x: Append "(cherry picked from commit ...)" to message (audit trail)
              # $XFLAG: Conflict resolution strategy flag (e.g., "-X ours")
              run_with_conflict_resolution "$N" "git cherry-pick --continue" \
                git cherry-pick -x $XFLAG "$MERGE_SHA"

              # Replace commit message with PR title + trailer
              # Why amend? Cherry-pick uses original merge commit message (often generic "Merge pull request #N")
              # We want PR title for better changelog generation
              # Preserve body: git log -1 --pretty=%b extracts body without subject
              BODY="$(git log -1 --pretty=%b HEAD || true)"
              if [ -n "$BODY" ]; then
                # Body exists: Keep it (may contain Co-authored-by, release notes, etc.)
                git commit --amend -m "$SUBJECT" -m "$BODY"
              else
                # No body: Just use subject
                git commit --amend -m "$SUBJECT"
              fi

              echo "::endgroup::"
              continue  # Skip to next PR
            fi

            # ===================================================================
            # BRANCH 2: Use PR head (open PR or mode=head)
            # ===================================================================
            # Fetch PR head branch from GitHub
            # Endpoint: pull/{N}/head refs are available for all PRs
            # Why not fetch from fork? Forks may be deleted or inaccessible
            echo "Cherry-picking OPEN PR #$N head"
            git fetch origin "pull/$N/head:pr-$N"

            if [ "$SQUASH" = "true" ]; then
              # ===============================================================
              # SQUASH MODE: Collapse all PR commits into single commit
              # ===============================================================
              # Why squash?
              #   - Clean prerelease history (one commit per PR)
              #   - Easier to revert entire PR if needed
              #   - Better for changelog generation
              # Trade-off: Loses per-commit granularity

              echo "  - Squashing with templated commit subject"

              # git merge --squash: Merge changes but don't commit
              # Why --squash? Stages all changes as one commit, not as merge commit
              # $XFLAG: Conflict resolution strategy
              run_with_conflict_resolution "$N" "" \
                git merge --squash $XFLAG "pr-$N"

              # Create commit with PR title as message
              git commit -m "$SUBJECT" || {
                echo "::error::Failed to commit squashed changes for PR #$N"
                exit 1
              }
            else
              # ===============================================================
              # PRESERVE HISTORY MODE: Cherry-pick each commit individually
              # ===============================================================
              # Why preserve?
              #   - Maintains original commit authors
              #   - Preserves fine-grained history (useful for debugging)
              #   - Better for bisecting if something breaks
              # Trade-off: More commits in prerelease branch

              echo "  - Cherry-picking each commit (preserving history)"

              # List all commits in PR (from merge-base to head)
              # ^HEAD: Exclude commits already in current branch
              # pr-$N: Include commits in PR branch
              # --reverse: Apply oldest commit first (chronological order)
              # --no-merges: Skip merge commits (clean linear history)
              for C in $(git rev-list --reverse --no-merges ^HEAD "pr-$N"); do
                # Cherry-pick each commit with conflict resolution support
                # -x: Append cherry-pick provenance to message
                run_with_conflict_resolution "$N" "git cherry-pick --continue" \
                  git cherry-pick -x $XFLAG "$C"
              done
            fi

            echo "::endgroup::"
          done  # End PR loop

      # =========================================================================
      # VALIDATION: Check syntax after conflict resolution
      # =========================================================================
      # Why conditional? Only needed if conflicts were auto-resolved
      # Why important? Union merge may create syntactically invalid code
      # Scope: Ruby, YAML, JSON (can be extended)
      # Limitation: Syntax validation doesn't catch semantic errors
      - name: Validate syntax after conflict resolution
        if: env.HAD_CONFLICTS == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Syntax Validation"

          # ===================================================================
          # Ruby syntax validation
          # ===================================================================
          # Command: ruby -c <file> (checks syntax without executing)
          # Exit code: 0 if valid, 1 if syntax error
          # Why Ruby? This is a Ruby project (Lich)
          # Coverage: All .rb files in working tree (excluding .git/)
          echo "Checking Ruby syntax..."
          find . -name "*.rb" -not -path "./.git/*" -type f | while read -r file; do
            # Suppress output on success (>/dev/null), show on failure
            if ! ruby -c "$file" >/dev/null 2>&1; then
              # Syntax error detected - emit GitHub annotation
              # ::error file=<path>:: creates clickable error in UI
              echo "::error file=$file::Syntax error in $file"
              ruby -c "$file" || true  # Show error details
            fi
          done

          # ===================================================================
          # YAML syntax validation
          # ===================================================================
          # Command: ruby -e "require 'yaml'; YAML.load_file(...)"
          # Why Ruby? Already available, YAML gem is stdlib
          # Why warning not error? YAML issues may be non-fatal (deprecated syntax)
          # Coverage: All .yml and .yaml files
          echo "Checking YAML syntax..."
          find . \( -name "*.yml" -o -name "*.yaml" \) -not -path "./.git/*" -type f | while read -r file; do
            if ! ruby -e "require 'yaml'; YAML.load_file('$file')" >/dev/null 2>&1; then
              # YAML issue detected - emit warning (not error)
              echo "::warning file=$file::Potential YAML syntax issue in $file"
            fi
          done

          # ===================================================================
          # JSON syntax validation
          # ===================================================================
          # Command: jq empty <file> (validates JSON, outputs nothing)
          # Why jq? Already ensured available in earlier step
          # Exit code: 0 if valid, 1 if invalid
          # Coverage: All .json files (configs, manifests)
          echo "Checking JSON syntax..."
          find . -name "*.json" -not -path "./.git/*" -type f | while read -r file; do
            if ! jq empty "$file" >/dev/null 2>&1; then
              # JSON syntax error - emit GitHub annotation
              echo "::error file=$file::JSON syntax error in $file"
              jq empty "$file" || true  # Show error details
            fi
          done

          echo "::endgroup::"
          echo "Syntax validation completed. Review warnings above."

      # =========================================================================
      # PUSH: Upload destination branch to remote
      # =========================================================================
      # Behavior:
      #   - dry_run=true: Show what would be pushed, don't actually push
      #   - reset_destination=true: Force push (history was rewritten)
      #   - Otherwise: Regular push (fast-forward or --no-ff merge)
      #
      # Why force-with-lease instead of force?
      #   - Safety: Only force-push if remote matches expected state
      #   - Prevents overwriting concurrent changes by other workflows/users
      #   - Trade-off: May fail if remote updated, but that's better than data loss
      - name: Push destination branch
        env:
          DEST: ${{ steps.guard_validate.outputs.dest_safe }}
          RESET: ${{ inputs.reset_destination }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            # DRY-RUN MODE: Show what would happen without pushing
            # Why? Allows testing workflow logic without modifying remote
            echo "::notice::[DRY-RUN] Would push to: $DEST"
            echo "::group::Git Log Preview"
            git log --oneline -10  # Show last 10 commits that would be pushed
            echo "::endgroup::"
            exit 0  # Exit successfully without pushing
          fi

          # LIVE MODE: Actually push to remote
          if [ "$RESET" = "true" ]; then
            # Force push (with safety check)
            # Why? reset_destination=true means we rewrote history
            # --force-with-lease: Only push if remote matches expected state
            #   - Prevents overwriting concurrent updates
            #   - Fails if someone else pushed since we fetched
            git push --force-with-lease origin "$DEST"
          else
            # Regular push (fast-forward or merge commit)
            # Why no --force? We built on top of existing history
            # May fail if: Remote updated concurrently (correct behavior - retry workflow)
            git push origin "$DEST"
          fi

      # =========================================================================
      # REPORTING: Generate conflict resolution report
      # =========================================================================
      # Why always()? Run even if previous steps failed (best-effort reporting)
      # Behavior:
      #   - If no conflicts: No output (no noise)
      #   - If conflicts auto-resolved: Write detailed report to GitHub Summary
      # Report includes:
      #   - List of all conflicted files
      #   - Preview of union-merged content
      #   - Manual review checklist
      #   - Warning annotations
      - name: Report conflict resolutions
        if: always()
        env:
          STRAT: ${{ inputs.conflict_strategy }}
        run: |
          # Only report if conflicts were resolved via union merge
          if [ "$HAD_CONFLICTS" = "true" ] && [ "$STRAT" = "both" ]; then
            {
              echo ""
              echo "---"
              echo ""
              echo "# âš ï¸ MANUAL REVIEW REQUIRED"
              echo ""
              echo "The workflow used **union merge** strategy to automatically resolve conflicts."
              echo "**This is EXPERIMENTAL and may have introduced syntax errors or logic issues.**"
              echo ""
              echo "## Required Actions:"
              echo "1. Review all conflicted files listed below"
              echo "2. Run full test suite before deploying"
              echo "3. Manually inspect union-merged code sections"
              echo ""
              echo "---"
              echo ""
              # Append accumulated conflict log (file paths, previews, etc.)
              cat "$CONFLICT_LOG_FILE"
            } >> "$GITHUB_STEP_SUMMARY"

            # Emit workflow-level warning (appears at top of workflow run)
            echo "::warning::Union merge strategy was used. MANUAL REVIEW REQUIRED before deployment!"
          fi

      # =========================================================================
      # SUMMARY: Final status report
      # =========================================================================
      # Why always()? Provide summary even if workflow failed (helps debugging)
      # Content:
      #   - Workflow parameters (destination, base, PRs, strategy, mode)
      #   - Conflict status
      #   - Next steps (context-specific recommendations)
      - name: Summary
        if: always()
        env:
          DEST: ${{ steps.guard_validate.outputs.dest_safe }}
          BASE: ${{ steps.guard_validate.outputs.base_safe }}
          PRS:  ${{ inputs.prs }}
          STRAT: ${{ inputs.conflict_strategy }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          {
            echo "### Curate Pre Branch Results"
            echo ""

            # Show mode (dry-run vs live)
            if [ "$DRY_RUN" = "true" ]; then
              echo "**Mode:** ðŸ§ª DRY-RUN (no changes pushed)"
            else
              echo "**Mode:** âœ… Live (changes pushed)"
            fi

            # List workflow parameters for reference
            echo "- **Destination:** \`$DEST\`"
            echo "- **Base:** \`$BASE\`"
            echo "- **PRs included:** $PRS"
            echo "- **Conflict strategy:** $STRAT"

            # Context-specific next steps
            if [ "$HAD_CONFLICTS" = "true" ] && [ "$STRAT" = "both" ]; then
              # Conflicts were auto-resolved - emphasize manual review
              echo "- **âš ï¸ Conflicts auto-resolved:** Yes (see warnings above)"
              echo ""
              echo "### ðŸš¨ Next Steps (IMPORTANT)"
              echo "1. Review conflict resolutions in detail above"
              echo "2. Run full test suite: \`bundle exec rspec\`"
              echo "3. Manual code review of all conflicted files"
              echo "4. If tests pass and code looks good, proceed with **Prepare Pre-release**"
            else
              # No conflicts or none auto-resolved - normal flow
              echo "- **Conflicts:** None"
              echo ""
              echo "### Next Steps"
              echo "Run **Prepare Pre-release** targeting \`$DEST\`"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
